import NodeClam from 'clamscan';
import { promises as fs } from 'fs';
import { createReadStream } from 'fs';
import { Readable } from 'stream';

export interface MalwareScanResult {
  isClean: boolean;
  isInfected: boolean;
  viruses: string[];
  scanTime: number;
  fileSize: number;
}

export interface MalwareScannerConfig {
  removeInfected: boolean;
  quarantineInfected: boolean;
  scanLog?: string;
  debugMode: boolean;
  maxFileSize: number;
  timeout: number;
  enabled: boolean;
  fallbackToMock: boolean;
}

/**
 * SECURITY: Malware scanning service for uploaded files
 * Provides ClamAV integration with proper fallback and error handling
 */
export class MalwareScannerService {
  private clamscan: any = null;
  private isInitialized: boolean = false;
  private config: MalwareScannerConfig;
  private initializationPromise: Promise<void> | null = null;

  constructor(config?: Partial<MalwareScannerConfig>) {
    this.config = {
      removeInfected: false, // Let application handle infected files
      quarantineInfected: false, // Let application handle quarantine
      debugMode: false,
      maxFileSize: 25 * 1024 * 1024, // 25MB limit
      timeout: 120000, // 2 minutes
      enabled: true,
      fallbackToMock: true, // Allow fallback when ClamAV unavailable
      ...config
    };
  }

  /**
   * Initialize the ClamAV scanner with proper error handling
   */
  private async initializeScanner(): Promise<void> {
    if (this.initializationPromise) {
      return this.initializationPromise;
    }

    this.initializationPromise = this._doInitialize();
    return this.initializationPromise;
  }

  private async _doInitialize(): Promise<void> {
    if (!this.config.enabled) {
      console.log('Malware scanning disabled by configuration');
      return;
    }

    try {
      console.log('Initializing ClamAV scanner...');
      
      this.clamscan = await new NodeClam().init({
        removeInfected: this.config.removeInfected,
        quarantineInfected: this.config.quarantineInfected,
        scanRecursively: false, // Only scan individual files
        debugMode: this.config.debugMode,
        clamdscan: {
          socket: '/var/run/clamav/clamd.ctl',
          host: '127.0.0.1',
          port: 3310,
          timeout: this.config.timeout,
          localFallback: true, // Fall back to clamscan binary if daemon unavailable
          multiscan: false, // Disable multiscan for single file scanning
          reloadDb: false, // Don't reload virus database on each scan
        },
        preference: 'clamdscan' // Prefer daemon for better performance
      });

      this.isInitialized = true;
      console.log('ClamAV scanner initialized successfully');
    } catch (error) {
      console.error('Failed to initialize ClamAV scanner:', error);
      
      if (this.config.fallbackToMock) {
        console.log('Falling back to mock scanner due to ClamAV unavailability');
        this.isInitialized = false; // Will use mock scanning
      } else {
        throw new Error('ClamAV initialization failed and fallback is disabled');
      }
    }
  }

  /**
   * SECURITY: Scan a file buffer for malware
   */
  async scanBuffer(buffer: Buffer, filename?: string): Promise<MalwareScanResult> {
    const startTime = Date.now();
    
    try {
      // SECURITY: Validate file size before processing
      if (buffer.length > this.config.maxFileSize) {
        throw new Error(`File size ${buffer.length} bytes exceeds maximum allowed size of ${this.config.maxFileSize} bytes`);
      }

      if (buffer.length === 0) {
        throw new Error('Cannot scan empty buffer');
      }

      await this.initializeScanner();

      if (this.isInitialized && this.clamscan) {
        // Real ClamAV scanning
        console.log(`Scanning buffer (${buffer.length} bytes) with ClamAV...`);
        
        const { isInfected, viruses } = await this.clamscan.scanBuffer(buffer, this.config.timeout);
        
        const scanTime = Date.now() - startTime;
        console.log(`ClamAV scan completed in ${scanTime}ms - Clean: ${!isInfected}`);

        return {
          isClean: !isInfected,
          isInfected: !!isInfected,
          viruses: viruses || [],
          scanTime,
          fileSize: buffer.length
        };
      } else {
        // Mock scanning when ClamAV is unavailable
        return this.performMockScan(buffer, startTime, filename);
      }
    } catch (error) {
      console.error('Malware scan failed:', error);
      
      if (this.config.fallbackToMock) {
        console.log('Falling back to mock scan due to scanning error');
        return this.performMockScan(buffer, startTime, filename);
      } else {
        throw new Error(`Malware scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }
  }

  /**
   * SECURITY: Scan a readable stream for malware
   */
  async scanStream(stream: Readable, filename?: string): Promise<MalwareScanResult> {
    const startTime = Date.now();
    
    try {
      await this.initializeScanner();

      if (this.isInitialized && this.clamscan) {
        console.log(`Scanning stream with ClamAV...`);
        
        const { isInfected, viruses } = await this.clamscan.scanStream(stream, this.config.timeout);
        
        const scanTime = Date.now() - startTime;
        console.log(`ClamAV stream scan completed in ${scanTime}ms - Clean: ${!isInfected}`);

        return {
          isClean: !isInfected,
          isInfected: !!isInfected,
          viruses: viruses || [],
          scanTime,
          fileSize: 0 // Size unknown for streams
        };
      } else {
        // For mock scanning, we need to read the stream into a buffer
        const chunks: Buffer[] = [];
        let totalSize = 0;

        for await (const chunk of stream) {
          totalSize += chunk.length;
          if (totalSize > this.config.maxFileSize) {
            throw new Error(`Stream size exceeds maximum allowed size of ${this.config.maxFileSize} bytes`);
          }
          chunks.push(chunk);
        }

        const buffer = Buffer.concat(chunks);
        return this.performMockScan(buffer, startTime, filename);
      }
    } catch (error) {
      console.error('Stream malware scan failed:', error);
      throw new Error(`Stream malware scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * SECURITY: Mock scanning for development/fallback scenarios
   * Performs basic security checks and threat detection patterns
   */
  private performMockScan(buffer: Buffer, startTime: number, filename?: string): MalwareScanResult {
    console.log(`Performing mock malware scan for ${filename || 'buffer'} (${buffer.length} bytes)`);
    
    // SECURITY: Basic threat detection patterns
    const threatPatterns = [
      // Executable signatures that shouldn't be in documents
      Buffer.from([0x4D, 0x5A]), // MZ header (Windows executable)
      Buffer.from([0x7F, 0x45, 0x4C, 0x46]), // ELF header (Linux executable)
      Buffer.from([0xFE, 0xED, 0xFA, 0xCE]), // Mach-O header (macOS executable)
      Buffer.from([0xFE, 0xED, 0xFA, 0xCF]), // Mach-O 64-bit header
      
      // Script patterns that could indicate malicious content
      Buffer.from('eval('), // JavaScript eval
      Buffer.from('exec('), // Code execution
      Buffer.from('system('), // System calls
      Buffer.from('<script'), // HTML script tags
      Buffer.from('<?php'), // PHP code
      
      // Common malware strings
      Buffer.from('virus'), // Simple virus indicator
      Buffer.from('malware'), // Malware indicator
      Buffer.from('trojan'), // Trojan indicator
    ];

    // Check for suspicious patterns
    const foundThreats: string[] = [];
    
    for (const pattern of threatPatterns) {
      if (buffer.includes(pattern)) {
        const patternStr = pattern.toString('ascii').replace(/[^\x20-\x7E]/g, '?');
        foundThreats.push(`Suspicious pattern detected: ${patternStr}`);
      }
    }

    // Additional checks for executable files disguised as documents
    if (filename) {
      const suspiciousExtensions = ['.exe', '.bat', '.cmd', '.scr', '.com', '.pif'];
      const lowercaseFilename = filename.toLowerCase();
      
      if (suspiciousExtensions.some(ext => lowercaseFilename.includes(ext))) {
        foundThreats.push(`Suspicious file extension in filename: ${filename}`);
      }
    }

    const scanTime = Date.now() - startTime;
    const isInfected = foundThreats.length > 0;
    
    console.log(`Mock scan completed in ${scanTime}ms - Threats found: ${foundThreats.length}`);
    
    return {
      isClean: !isInfected,
      isInfected,
      viruses: foundThreats,
      scanTime,
      fileSize: buffer.length
    };
  }

  /**
   * Check if scanner is ready for use
   */
  async isReady(): Promise<boolean> {
    if (!this.config.enabled) {
      return false;
    }

    try {
      await this.initializeScanner();
      return this.isInitialized || this.config.fallbackToMock;
    } catch {
      return this.config.fallbackToMock;
    }
  }

  /**
   * Get scanner status information
   */
  async getStatus(): Promise<{
    enabled: boolean;
    initialized: boolean;
    usingMock: boolean;
    version?: string;
  }> {
    await this.initializeScanner();
    
    let version = undefined;
    if (this.isInitialized && this.clamscan) {
      try {
        version = await this.clamscan.getVersion();
      } catch {
        // Version check failed, continue without it
      }
    }

    return {
      enabled: this.config.enabled,
      initialized: this.isInitialized,
      usingMock: !this.isInitialized && this.config.fallbackToMock,
      version
    };
  }

  /**
   * Update virus definitions (if using real ClamAV)
   */
  async updateDefinitions(): Promise<boolean> {
    if (!this.isInitialized || !this.clamscan) {
      throw new Error('ClamAV not initialized - cannot update definitions');
    }

    try {
      console.log('Updating ClamAV virus definitions...');
      // Note: This requires freshclam to be available and properly configured
      await this.clamscan.reload();
      console.log('Virus definitions updated successfully');
      return true;
    } catch (error) {
      console.error('Failed to update virus definitions:', error);
      return false;
    }
  }
}

// Export singleton instance with production configuration
export const malwareScannerService = new MalwareScannerService({
  enabled: true,
  fallbackToMock: true, // Allow fallback in environments without ClamAV
  debugMode: false,
  maxFileSize: 25 * 1024 * 1024, // 25MB limit
  timeout: 120000 // 2 minutes timeout
});